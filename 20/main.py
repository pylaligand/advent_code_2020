#!/usr/bin/python

import argparse
from collections import namedtuple
from copy import copy
import re
import sys

TileState = namedtuple('TileState', ['flipped', 'rotation'])
Constraint = namedtuple('Constraint', ['edge', 'value'])
PlacedTile = namedtuple('PlacedTile', ['id', 'state'])

ALL_STATES = [
    TileState(f, r) for f in [False, True] for r in [0, 90, 180, 270]
]


class Edge(object):
    TOP = 1
    BOTTOM = 2
    LEFT = 3
    RIGHT = 4

    @classmethod
    def opposite(cls, edge):
        if edge == Edge.TOP:
            return Edge.BOTTOM
        elif edge == Edge.BOTTOM:
            return Edge.TOP
        elif edge == Edge.LEFT:
            return Edge.RIGHT
        elif edge == Edge.RIGHT:
            return Edge.LEFT


class Direction(object):
    NORMAL = False
    REVERSE = True


class Snap(object):
    def __init__(self, pixels, width, height):
        self._pixels = pixels
        self.width = width
        self.height = height

    def __repr__(self):
        return repr(self._pixels)

    def pretty_print(self):
        for x in range(0, self.width):
            for y in range(0, self.height):
                sys.stdout.write('#' if self.get(x, y) else '.')
            sys.stdout.write('\n')
        sys.stdout.flush()

    def count(self):
        return len(self._pixels)

    def get(self, x, y):
        if x < 0 or x >= self.width or y < 0 or y >= self.height:
            raise Exception('Coordinates (%s, %s) out of bounds (%s, %s)' %
                            (x, y, self.width, self.height))
        return self._pixels.get((x, y), False)


class Tile(object):
    def __init__(self, lines):
        self._data = {}
        self._width = len(lines)
        self._height = len(lines[0])
        for x, line in enumerate(lines):
            for y, c in enumerate(line):
                if c == '#':
                    self._data[(x, y)] = True
        self._compute_edges()

    def __repr__(self):
        return str(self._data)

    def pretty_print(self):
        for x in range(0, self._width):
            for y in range(0, self._height):
                sys.stdout.write('#' if self._get(x, y) else '.')
            sys.stdout.write('\n')
        sys.stdout.flush()

    def _get(self, x, y):
        return self._data.get((x, y), False)

    def _compute_edges(self):
        # Edge values are generated by interpreting line pixels as bits, with
        # lower bits corresponding lower x/y values.
        # Edge values are actually computed in both directions in case the tile
        # ends up flipped.
        self._edges = {
            Edge.TOP: {
                Direction.NORMAL:
                sum(1 << i for i, y in enumerate(range(0, self._height))
                    if self._get(0, y)),
                Direction.REVERSE:
                sum(1 << i
                    for i, y in enumerate(reversed(range(0, self._height)))
                    if self._get(0, y)),
            },
            Edge.BOTTOM: {
                Direction.NORMAL:
                sum(1 << i for i, y in enumerate(range(0, self._height))
                    if self._get(self._width - 1, y)),
                Direction.REVERSE:
                sum(1 << i
                    for i, y in enumerate(reversed(range(0, self._height)))
                    if self._get(self._width - 1, y)),
            },
            Edge.LEFT: {
                Direction.NORMAL:
                sum(1 << i for i, x in enumerate(range(0, self._width))
                    if self._get(x, 0)),
                Direction.REVERSE:
                sum(1 << i
                    for i, x in enumerate(reversed(range(0, self._width)))
                    if self._get(x, 0)),
            },
            Edge.RIGHT: {
                Direction.NORMAL:
                sum(1 << i for i, x in enumerate(range(0, self._width))
                    if self._get(x, self._height - 1)),
                Direction.REVERSE:
                sum(1 << i
                    for i, x in enumerate(reversed(range(0, self._width)))
                    if self._get(x, self._height - 1)),
            },
        }

    def get_edge(self, edge, state):
        if state.flipped:
            # Note: "flipped" with no rotation amounts to flipping the x and y
            # axes.
            if state.rotation == 0:
                if edge == Edge.TOP:
                    return self._edges[Edge.LEFT][Direction.NORMAL]
                elif edge == Edge.BOTTOM:
                    return self._edges[Edge.RIGHT][Direction.NORMAL]
                elif edge == Edge.LEFT:
                    return self._edges[Edge.TOP][Direction.NORMAL]
                elif edge == Edge.RIGHT:
                    return self._edges[Edge.BOTTOM][Direction.NORMAL]
            elif state.rotation == 90:
                if edge == Edge.TOP:
                    return self._edges[Edge.BOTTOM][Direction.NORMAL]
                elif edge == Edge.BOTTOM:
                    return self._edges[Edge.TOP][Direction.NORMAL]
                elif edge == Edge.LEFT:
                    return self._edges[Edge.LEFT][Direction.REVERSE]
                elif edge == Edge.RIGHT:
                    return self._edges[Edge.RIGHT][Direction.REVERSE]
            elif state.rotation == 180:
                if edge == Edge.TOP:
                    return self._edges[Edge.RIGHT][Direction.REVERSE]
                elif edge == Edge.BOTTOM:
                    return self._edges[Edge.LEFT][Direction.REVERSE]
                elif edge == Edge.LEFT:
                    return self._edges[Edge.BOTTOM][Direction.REVERSE]
                elif edge == Edge.RIGHT:
                    return self._edges[Edge.TOP][Direction.REVERSE]
            elif state.rotation == 270:
                if edge == Edge.TOP:
                    return self._edges[Edge.TOP][Direction.REVERSE]
                elif edge == Edge.BOTTOM:
                    return self._edges[Edge.BOTTOM][Direction.REVERSE]
                elif edge == Edge.LEFT:
                    return self._edges[Edge.RIGHT][Direction.NORMAL]
                elif edge == Edge.RIGHT:
                    return self._edges[Edge.LEFT][Direction.NORMAL]
        else:  # not state.flipped
            if state.rotation == 0:
                return self._edges[edge][Direction.NORMAL]
            elif state.rotation == 90:
                if edge == Edge.TOP:
                    return self._edges[Edge.RIGHT][Direction.NORMAL]
                elif edge == Edge.BOTTOM:
                    return self._edges[Edge.LEFT][Direction.NORMAL]
                elif edge == Edge.LEFT:
                    return self._edges[Edge.TOP][Direction.REVERSE]
                elif edge == Edge.RIGHT:
                    return self._edges[Edge.BOTTOM][Direction.REVERSE]
            elif state.rotation == 180:
                if edge == Edge.TOP:
                    return self._edges[Edge.BOTTOM][Direction.REVERSE]
                elif edge == Edge.BOTTOM:
                    return self._edges[Edge.TOP][Direction.REVERSE]
                elif edge == Edge.LEFT:
                    return self._edges[Edge.RIGHT][Direction.REVERSE]
                elif edge == Edge.RIGHT:
                    return self._edges[Edge.LEFT][Direction.REVERSE]
            elif state.rotation == 270:
                if edge == Edge.TOP:
                    return self._edges[Edge.LEFT][Direction.REVERSE]
                elif edge == Edge.BOTTOM:
                    return self._edges[Edge.RIGHT][Direction.REVERSE]
                elif edge == Edge.LEFT:
                    return self._edges[Edge.BOTTOM][Direction.NORMAL]
                elif edge == Edge.RIGHT:
                    return self._edges[Edge.TOP][Direction.NORMAL]

    def snap(self, state):
        # Compute the iteration order depending on the desired state.
        base_x_range = range(1, self._width - 1)
        base_y_range = range(1, self._height - 1)
        if state.flipped:
            if state.rotation == 0:
                x_first = False
                x_range = base_y_range
                y_range = base_x_range
            elif state.rotation == 90:
                x_first = True
                x_range = list(reversed(base_x_range))
                y_range = base_y_range
            elif state.rotation == 180:
                x_first = False
                x_range = list(reversed(base_y_range))
                y_range = list(reversed(base_x_range))
            elif state.rotation == 270:
                x_first = True
                x_range = base_x_range
                y_range = list(reversed(base_y_range))
        else:
            if state.rotation == 0:
                x_first = True
                x_range = base_x_range
                y_range = base_y_range
            elif state.rotation == 90:
                x_first = False
                x_range = list(reversed(base_y_range))
                y_range = base_x_range
            elif state.rotation == 180:
                x_first = True
                x_range = list(reversed(base_x_range))
                y_range = list(reversed(base_y_range))
            elif state.rotation == 270:
                x_first = False
                x_range = base_y_range
                y_range = list(reversed(base_x_range))

        pixels = {}
        for i_f, f in enumerate(x_range):
            for i_s, s in enumerate(y_range):
                source_coords = (f if x_first else s, s if x_first else f)
                dest_coords = (i_f, i_s)
                if source_coords in self._data:
                    pixels[dest_coords] = True

        return Snap(pixels, (self._width if x_first else self._height) - 2,
                    (self._height if x_first else self._width) - 2)


class Picture(object):
    def __init__(self, snaps):
        self._snaps = snaps
        x_snaps = [s for (c, s) in self._snaps.iteritems() if c[0] == 0]
        self._snap_width = x_snaps[0].width
        self._width = len(x_snaps) * self._snap_width
        y_snaps = [s for (c, s) in self._snaps.iteritems() if c[1] == 0]
        self._snap_height = y_snaps[0].height
        self._height = len(y_snaps) * self._snap_height

    def __repr__(self):
        return repr(self._snaps)

    def pretty_print(self):
        for x in range(0, self._width):
            for y in range(0, self._height):
                sys.stdout.write('#' if self._get(x, y) else '.')
            sys.stdout.write('\n')
        sys.stdout.flush()

    def _get(self, x, y):
        snap_x = x // self._snap_width
        snap_y = y // self._snap_height
        snap = self._snaps[(snap_x, snap_y)]
        x_in_snap = x % self._snap_width
        y_in_snap = y % self._snap_height
        return snap.get(x_in_snap, y_in_snap)

    def find(self, target):
        fit_count = 0
        for x in range(0, self._width - target.width):
            for y in range(0, self._height - target.height):
                if self._fit(target, x, y):
                    fit_count += 1
        if not fit_count:
            return 0
        return sum(s.count()
                   for s in self._snaps.values()) - fit_count * target.count()

    def _fit(self, target, xc, yc):
        for x in range(0, target.width):
            for y in range(0, target.height):
                if not target.get(x, y):
                    continue
                if not self._get(x + xc, y + yc):
                    return False
        return True


class Assembly(object):
    def __init__(self, tiles):
        self._tiles = tiles
        # Records a partial arrangement of the tiles.
        # Format: (x, y) -> PlacedTile
        self._pieces = {}

    def __repr__(self):
        return repr(self._pieces)

    def __copy__(self):
        result = Assembly(copy(self._tiles))
        result._pieces = copy(self._pieces)
        return result

    def is_complete(self):
        return all(
            any(pt.id == t for pt in self._pieces.values())
            for t in self._tiles.keys())

    def _ensure_complete(self):
        if not self.is_complete():
            raise Exception('Need to complete assembly first!')

    def _get_extent(self):
        self._ensure_complete()
        min_x = min(x for x, _ in self._pieces)
        max_x = max(x for x, _ in self._pieces)
        min_y = min(y for _, y in self._pieces)
        max_y = max(y for _, y in self._pieces)
        return (min_x, max_x, min_y, max_y)

    def get_picture(self):
        self._ensure_complete()
        min_x, max_x, min_y, max_y = self._get_extent()
        snaps = {}
        for i, x in enumerate(range(min_x, max_x + 1)):
            for j, y in enumerate(range(min_y, max_y + 1)):
                placement = self._pieces[(x, y)]
                tile = self._tiles[placement.id]
                snaps[(i, j)] = tile.snap(placement.state)
        return Picture(snaps)

    def corner_score(self):
        self._ensure_complete()
        min_x, max_x, min_y, max_y = self._get_extent()
        return (self._pieces[(min_x, min_y)].id *
                self._pieces[(min_x, max_y)].id *
                self._pieces[(max_x, min_y)].id *
                self._pieces[(max_x, max_y)].id)

    def add_piece(self, spot, placed_tile):
        if spot in self._pieces:
            raise Exception('Spot %s already occupied' % spot)
        if any(pt.id == placed_tile.id for pt in self._pieces.values()):
            raise Exception('Tile %s already placed' % placed_tile.id)
        self._pieces[spot] = placed_tile

    def generate_spots(self):
        def neighbors(spot):
            x, y = spot
            return {
                Edge.TOP: (x - 1, y),
                Edge.BOTTOM: (x + 1, y),
                Edge.LEFT: (x, y - 1),
                Edge.RIGHT: (x, y + 1),
            }

        # Find insertion spots for new pieces.
        available_spots = []
        for spot in self._pieces.keys():
            for n in neighbors(spot).values():
                if n in self._pieces:
                    continue
                available_spots.append(n)

        spots = {}  # (x, y) --> [Constraint]
        # Generate constraints for the new spots.
        for spot in available_spots:
            constraints = []
            for e, c in neighbors(spot).iteritems():
                if c not in self._pieces:
                    continue
                id, state = self._pieces[c]
                tile = self._tiles[id]
                constraints.append(
                    Constraint(e, tile.get_edge(Edge.opposite(e), state)))
            spots[spot] = constraints

        return spots

    def candidates(self):
        if not self._pieces:
            # The first tile is arbitrarily placed at the origin of the
            # assembly's coordinate system in the first available state.
            # Subsequent pieces should be placed relatively to that first piece.
            yield ((0, 0), PlacedTile(self._tiles.keys()[0], ALL_STATES[0]))
            return

        def match_constraints(tile, state, constraints):
            for c in constraints:
                if tile.get_edge(c.edge, state) != c.value:
                    return False
            return True

        spots = self.generate_spots()
        for id, tile in self._tiles.iteritems():
            if any(p[0] == id for p in self._pieces.values()):
                continue
            for spot, constraints in spots.iteritems():
                for state in ALL_STATES:
                    if match_constraints(tile, state, constraints):
                        yield (spot, PlacedTile(id, state))


def parse_tiles(lines):
    result = {}
    lines = [l for l in lines if l]
    while lines:
        line = lines.pop(0)
        id = int(re.match('^Tile (\d+):$', line).group(1))
        tile_lines = []
        while lines:
            line = lines[0]
            if line.startswith('Tile'):
                break
            tile_lines.append(lines.pop(0))
        result[id] = Tile(tile_lines)
    return result


def _build(assembly):
    if assembly.is_complete():
        return assembly
    for spot, placed_tile in assembly.candidates():
        next_assembly = copy(assembly)
        next_assembly.add_piece(spot, placed_tile)
        result = _build(next_assembly)
        if result:
            return result
    return None


def assemble(tiles):
    return _build(Assembly(tiles))


def find_corners(tiles):
    return assemble(tiles).corner_score()


MONSTER = Tile([
    '......................',
    '.                  # .',
    '.#    ##    ##    ###.',
    '. #  #  #  #  #  #   .',
    '......................',
])


def find_monster(tiles):
    assembly = assemble(tiles)
    picture = assembly.get_picture()
    for state in ALL_STATES:
        monster_snap = MONSTER.snap(state)
        total = picture.find(monster_snap)
        if total:
            return total


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('file')
    parser.add_argument('--next', action='store_true')
    args = parser.parse_args()

    with open(args.file, 'r') as input_file:
        lines = [l.strip() for l in input_file.readlines()]

    tiles = parse_tiles(lines)

    if args.next:
        print(find_monster(tiles))
    else:
        print(find_corners(tiles))


if __name__ == "__main__":
    main()
